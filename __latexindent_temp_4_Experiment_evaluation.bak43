\documentclass[../Main.tex]{subfiles}
\begin{document}

\tikzset{
    % Style cho Package (Khung bao ngoài)
    uml_package/.style={
        draw, rectangle, 
        minimum width=12cm, minimum height=8cm, 
        anchor=north, 
        fill=white, 
        drop shadow={opacity=0.3}
    },
    % Style cho Tab tên Package
    uml_package_tab/.style={
        draw, rectangle, 
        fill=white, 
        minimum width=3.5cm, minimum height=0.7cm, 
        font=\bfseries
    },
    % Style cho Class
    uml_class/.style={
        draw, rectangle, 
        minimum width=3.2cm, minimum height=1.2cm, 
        align=center, 
        fill=gray!5, 
        font=\bfseries\small,
        drop shadow={opacity=0.15}
    },
    % --- ĐỊNH NGHĨA QUAN HỆ UML (Sử dụng arrows.meta) ---
    % 1. Implementation (Thực thi/Hiện thực hóa): Nét đứt, đầu tam giác rỗng
    rel_implementation/.style={-{Triangle[open, length=3mm, width=3mm]}, dashed, thick},
    % 2. Aggregation (Kết tập): Đầu hình thoi trắng (rỗng)
    rel_aggregation/.style={{Diamond[open, length=3mm, width=3mm]}-, thick},
    % 3. Composition (Hợp thành): Đầu hình thoi đen (đặc)
    rel_composition/.style={{Diamond[fill=black, length=3mm, width=3mm]}-, thick},
    % 4. Association (Kết hợp): Đường thẳng
    rel_association/.style={-, thick}
}


\section{Architecture Design}

\subsection{Overall design}

The architectural design of the Multi-chain Stablecoin Protocol is founded upon a Hybrid Event-Driven Microservices framework, structured within a Hub-and-Spoke topology. This sophisticated architecture is engineered to resolve the inherent challenges of liquidity fragmentation and state synchronization across heterogeneous blockchain networks. By strictly decoupling the Asset Custody Layer (residing on EVM chains) from the State Execution Layer (residing on the Solana SVM), the system achieves a high-performance, scalable solution that leverages the distinct advantages of each blockchain environment.

The architecture is composed of three primary execution environments, each functioning as an autonomous system component yet interconnected through a secure event-driven pipeline. The first environment is the EVM Spoke, which hosts the Controller Contract. This contract functions as the user's primary interface and asset vault, designed to be lightweight and gas-efficient. Its responsibilities are strictly limited to asset locking, event emission, and state updates based on authorized callbacks. The second environment is the Solana Hub (SVM), which acts as the system's "Brain." It hosts the Gateway Contract for cryptographic verification and data formatting, and the Main Contract for executing the core business logic, such as managing the Universal Wallet and calculating dynamic Health Factors. The third environment, bridging the deterministic worlds of these blockchains, is the Off-chain Guardian Infrastructure. This middleware operates as an active listener and orchestrator, ensuring that state transitions on one chain are accurately and securely reflected on the other.

To visualize the interaction between these components and the directional flow of data, Figure \ref{fig:overall_arch} presents the detailed system architecture diagram.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.95\textwidth]{Figure/Overall_architecture.png}
    \caption{Detailed Architecture of the Multi-chain Stablecoin Protocol}
    \label{fig:overall_arch}
\end{figure}


The operational workflow of the system, as depicted in the diagram, follows a rigorous six-step process designed to ensure atomicity, security, and eventual consistency.

\paragraph{Step 1: Initiation and Request Encapsulation}
The process begins on the EVM chain where the user intends to perform an action, such as depositing collateral. The user constructs a message $M$ containing the action parameters (e.g., Token Address, Amount, Target Chain ID) and a unique nonce. Crucially, the user signs this message with their EVM private key, generating a signature $\sigma$. The user then submits a transaction to the \textbf{Controller Contract}. Upon receipt, the Controller does not immediately execute the cross-chain logic but performs two critical local actions: it locks the user's assets (in a Vault) and emits a `RequestCreated` event containing the message $M$ and signature $\sigma$. This emission acts as a signal flare to the off-chain infrastructure.

\paragraph{Step 2: Event Ingestion (The Listening Phase)}
Unlike traditional polling mechanisms that can be resource-intensive, the Guardian Server employs a reactive Event Listening model. It maintains an active WebSocket or HTTP connection to the EVM RPC nodes. When the `RequestCreated` event is emitted by the Controller, the Guardian immediately captures the log data. This step represents the "Event" in the Event-Driven Architecture. The Guardian parses the log to extract the raw data necessary for the state transition on the destination chain.

\paragraph{Step 3: Relaying and Submission}
Once the data is captured, the Guardian packages the original message $M$ and the signature $\sigma$ into a new transaction payload compatible with the Solana runtime. It then submits this transaction to the \textbf{Gateway Contract} on the SVM. In this phase, the Guardian acts strictly as a courier (Relayer); it does not modify the message content, ensuring that the user's original intent remains tamper-proof. The Guardian also manages the payment of SOL gas fees, abstracting the complexity of holding multiple native tokens from the end-user.

\paragraph{Step 4: Verification and Instruction Execution}
The \textbf{Gateway Contract} serves as the entry point to the Solana environment. Its primary responsibility is security. Before any business logic is executed, the Gateway invokes Solana's native `Secp256k1` program to cryptographically verify that the signature $\sigma$ corresponds to the user's EVM address contained in message $M$. This verification is performed on-chain, providing a trustless guarantee of identity. Upon successful verification, the Gateway formats the data into a structured Instruction and calls the \textbf{Main Contract}. The Main Contract then executes the core logic, such as creating a Universal Wallet PDA or updating the user's debt position.

\paragraph{Step 5: Outcome Observation}
Similar to the ingestion phase on the EVM side, the Guardian Server also maintains a listener on the Solana Blockchain. When the Main Contract finishes execution, it emits a specific event - either `ExecutionSuccess` (indicating the state was updated) or `ExecutionFailure` (indicating a logic error, such as low health factor). The Guardian listens for these specific outcome events to determine the final status of the cross-chain operation. This asynchronous confirmation step is vital for handling the probabilistic finality of blockchain networks.

\paragraph{Step 6: State Synchronization and Finalization}
Based on the event received from the Solana Main Contract, the Guardian initiates a final callback transaction to the EVM \textbf{Controller Contract} to close the loop. If the Solana execution was successful, the Guardian calls the `updateState` function to finalize the process (e.g., minting stablecoins to the user). If the Solana execution failed, the Guardian triggers a rollback mechanism, unlocking the user's assets and resetting their nonce. This ensures that the system maintains data consistency between the Asset Layer and the State Layer, preventing any funds from being permanently locked in transit.

\subsection{Detailed Package Design}

Based on the overall architecture, this section details the internal design of the critical subsystems. The design is visualized using Class Diagrams grouped by their respective execution environments.

\subsubsection{Solana Hub Package Design}
The Solana Hub Package, designated as package SolanaCore, encapsulates the system's central business logic and state management. This package is architected to ensure strict separation between the interface layer (Gateway), the logic layer (Main Contract and Managers), and the data layer (Wallet and Counters).
Figure \ref{fig:solana_detailed_design} illustrates the internal structure and class relationships within this package.

\pgfdeclarelayer{background}
\pgfdeclarelayer{foreground}
\pgfsetlayers{background,main,foreground}
\begin{figure}[htbp]
    \centering
    % Resizebox giúp hình to hết khổ giấy mà không bị tràn
    \resizebox{\textwidth}{!}{
    \begin{tikzpicture}[
        node distance=2.5cm,
        % --- STYLES ---
        uml_class/.style={
            draw, rectangle, 
            minimum width=4.5cm, minimum height=1.5cm, 
            align=center, 
            fill=gray!5, 
            font=\bfseries\large, % Font chữ to hơn
            drop shadow={opacity=0.15},
            thick
        },
        uml_package_style/.style={
            draw, rectangle, 
            inner sep=1cm, 
            fill=white, 
            drop shadow={opacity=0.2},
            rounded corners=2pt
        },
        uml_tab_style/.style={
            draw, rectangle, 
            fill=white, 
            minimum width=5cm, minimum height=1cm, 
            font=\bfseries\Large, 
            anchor=south west
        },
        % Quan hệ UML
        rel_impl/.style={-{Triangle[open, length=4mm, width=4mm]}, dashed, thick},
        rel_agg/.style={{Diamond[open, length=4mm, width=4mm]}-, thick},
        rel_comp/.style={{Diamond[fill=black, length=4mm, width=4mm]}-, thick},
        rel_assoc/.style={-, thick}
    ]

        % 1. VẼ CÁC CLASS (NODE) TRƯỚC
        
        % Hàng 1: Gateway ở giữa
        \node[uml_class] (gateway) at (0, 0) {GatewayContract};
        
        % Mở rộng khoảng cách sang 2 bên (x = -7 và x = 7)
        \node[uml_class] (formatter) at (-7.5, 0) {FormaterData};
        \node[uml_class] (verifier) at (7.5, 0) {SignatureVerifier};
        
        % Hàng 2: MainContract (Cách xa hơn chút)
        \node[uml_class] (main) at (0, -3.5) {MainContract};
        
        % Hàng 3: Position và Wallet (Mở rộng cân đối)
        \node[uml_class] (pos_mgmt) at (-7.5, -7) {PositionManagement};
        \node[uml_class] (wallet) at (7.5, -7) {UniversalWallet};
        \node[uml_class] (liq_mgmt) at (0, -10.5) {LiquidityManagement};
        
        % Hàng 4: NonceCounter (Nằm hẳn xuống dưới)
        \node[uml_class] (nonce) at (7.5, -10.5) {NonceCounter};

        % 2. VẼ CÁC ĐƯỜNG KẾT NỐI (RELATIONSHIPS)
        
        % (1) Implementation: Gateway -> Helper classes
        \draw[rel_impl] (gateway) -- (verifier);
        \draw[rel_impl] (gateway) -- (formatter);
        
        % (2) Aggregation: Gateway <>- MainContract
        \draw[rel_agg] (gateway) -- (main);
        
        % (3) Implementation: Main -> Position
        % Vẽ đường vuông góc đẹp
        \draw[rel_impl] (main.west) -| (pos_mgmt.north);
        
        % (4) Association: Main - Wallet
        \draw[rel_assoc] (main.east) -| (wallet.north);
        
        % (5) Association: Position - Wallet
        \draw[rel_assoc] (pos_mgmt) -- (wallet);
        
        % (6) Composition: Wallet *-- Nonce
        % Vẽ trực tiếp thẳng xuống
        \draw[rel_comp] (wallet) -- (nonce);

        \draw[rel_impl] (main) -- (liq_mgmt);

        % 3. VẼ KHUNG PACKAGE (NẰM Ở LAYER BACKGROUND)
        % Điều này đảm bảo khung không bao giờ che mất class
        \begin{pgfonlayer}{background}
            % Fit bao gồm tất cả các node biên
            \node[uml_package_style, fit=(formatter) (verifier) (nonce) (pos_mgmt) (gateway)] (pkg_box) {};
            
            % Vẽ Tab tên Package
            \node[uml_tab_style] at (pkg_box.north west) {pkg SolanaCore};
        \end{pgfonlayer}

    \end{tikzpicture}
    }
    \caption{Detailed Design of Solana Hub Package}
    \label{fig:solana_detailed_design}
\end{figure}

\textbf{Class Descriptions and Relationships:}
\begin{itemize}
\item \textbf{GatewayContract:} This class acts as the single entry point for all cross-chain transactions initiated by the Guardian. It serves as an orchestrator that sanitizes inputs before passing control to the core logic.
    \begin{itemize}
        \item Implementation Relationships: The Gateway implements logic from Formater Data class to deserialize incoming payloads and utilizes the Signature Verifier to perform cryptographic checks (Secp256k1 recovery) on the user's signature.
        \item Aggregation: It maintains an aggregation relationship with the Main Contract, indicating that the Gateway coordinates the execution flow but delegates the actual financial state transitions to the Main Contract.
    \end{itemize}
\item \textbf{MainContract:} This is the core controller of the system. It manages the lifecycle of CDPs and coordinates liquidity across chains. To maintain modularity, it splits complex operations into specialized management modules:
    \begin{itemize}
        \item It implements the Position Management module to handle collateral locking, debt minting, and health factor calculations.
        \item It implements the Liquidity Management module to handle the rebalancing of assets between the Hub and Spokes during liquidations.
    \end{itemize}

\item \textbf{UniversalWallet:} This class represents the persistent state (Program Derived Address - PDA) of a user. It stores the aggregated data of collateral and debt.
    \begin{itemize}
        \item Association: Both the Main Contract and Position Management have direct associations with the Universal Wallet to read and modify the user's financial position.
    \end{itemize}

\item \textbf{NonceCounter:} This class tracks the sequence number of transactions to prevent replay attacks.
    \begin{itemize}
        \item Composition: The diagram defines a strict composition relationship (filled diamond) between Universal Wallet and Nonce Counter. This implies that the Nonce Counter is an intrinsic part of the Wallet; it cannot exist independently, and its lifecycle is bound to the existence of the Universal Wallet.
    \end{itemize}
\end{itemize}

\subsubsection{Guardian Middleware Package Design}
The Guardian Middleware Package, designated as package GuardianService, acts as the off-chain orchestration layer. It is designed using an Event-Driven architecture to handle the asynchronous nature of cross-chain communication reliably.

Figure \ref{fig:guardian_detailed_design} depicts the internal class design of the Guardian node.

\begin{figure}[htbp]
    \centering
    \resizebox{\textwidth}{!}{
    \begin{tikzpicture}[
        node distance=2.5cm,
        % --- STYLES (Dùng lại style chuẩn của hình trước) ---
        uml_class/.style={
            draw, rectangle, 
            minimum width=4.5cm, minimum height=1.5cm, 
            align=center, 
            fill=gray!5, 
            font=\bfseries\large, 
            drop shadow={opacity=0.15},
            thick
        },
        uml_package_style/.style={
            draw, rectangle, 
            inner sep=1cm, 
            fill=white, 
            drop shadow={opacity=0.2},
            rounded corners=2pt
        },
        uml_tab_style/.style={
            draw, rectangle, 
            fill=white, 
            minimum width=5cm, minimum height=1cm, 
            font=\bfseries\Large, 
            anchor=south west
        },
        % Quan hệ UML
        rel_impl/.style={-{Triangle[open, length=4mm, width=4mm]}, dashed, thick}, % Thực thi / Phụ thuộc
        rel_agg/.style={{Diamond[open, length=4mm, width=4mm]}-, thick}, % Kết tập
        rel_comp/.style={{Diamond[fill=black, length=4mm, width=4mm]}-, thick}, % Hợp thành
        rel_assoc/.style={-, thick} % Kết hợp
    ]

        % 1. VẼ CÁC CLASS (NODE)
        
        % Trung tâm: EventQueue (Hàng đợi)
        \node[uml_class] (queue) at (0, 0) {EventQueue};
        
        % Bên Trái: Listener và Interface RPC
        \node[uml_class] (listener) at (-6, 0) {EventListener};
        \node[uml_class] (rpc) at (-6, 3.5) {<<Interface>>\\IRpcProvider};
        
        % Bên Phải: Orchestrator (Bộ điều phối)
        \node[uml_class] (orchestrator) at (6, 0) {TxOrchestrator};
        
        % Bên Dưới: Các thành phần hỗ trợ cho Orchestrator
        \node[uml_class] (signer) at (3.5, -4) {KeyManager};
        \node[uml_class] (relayer) at (8.5, -4) {SolanaRelayer};

        % 2. VẼ CÁC ĐƯỜNG KẾT NỐI
        
        % (1) Implementation: EventListener dùng IRpcProvider
        \draw[rel_impl] (listener) -- (rpc);
        
        % (2) Association: Listener đẩy vào Queue (Mũi tên ngang)
        \draw[rel_assoc] (listener) -- (queue);
        
        % (3) Association: Orchestrator lấy từ Queue
        \draw[rel_assoc] (queue) -- (orchestrator);
        
        % (4) Composition: Orchestrator sở hữu KeyManager (Bắt buộc phải có để ký)
        % Orchestrator *-- KeyManager
        \draw[rel_comp] (orchestrator.south) -- ++(0,-1) -| (signer.north);
        
        % (5) Aggregation: Orchestrator dùng SolanaRelayer (Để gửi tx)
        % Orchestrator <>- SolanaRelayer
        \draw[rel_agg] (orchestrator.south) -- ++(0,-1) -| (relayer.north);

        % 3. VẼ KHUNG PACKAGE (LAYER BACKGROUND)
        \begin{pgfonlayer}{background}
            % Fit bao gồm tất cả các node
            \node[uml_package_style, fit=(rpc) (listener) (relayer) (signer)] (pkg_box) {};
            % Vẽ Tab tên Package
            \node[uml_tab_style] at (pkg_box.north west) {pkg GuardianService};
        \end{pgfonlayer}

    \end{tikzpicture}
    }
    \caption{Detailed Design of Guardian Middleware Package}
    \label{fig:guardian_detailed_design}
\end{figure}

\textbf{Class Descriptions and Relationships:}

\begin{itemize}
    \item \textbf{EventListener:} This component is responsible for monitoring blockchain networks. It implements the IRpcProvider interface to maintain agnostic connections to various EVM chains (Ethereum, BSC, Arbitrum). Its primary role is to detect RequestCreated logs and normalize them into a standard event format.
    
    \item \textbf{EventQueue:} Acting as a buffer, this class decouples the ingestion layer (Listener) from the processing layer (Orchestrator). It ensures that during high network traffic, events are not lost but queued for sequential processing.
    
    \item \textbf{TxOrchestrator:} This is the core logic unit of the middleware. It consumes events from the queue, validates the data integrity, and constructs the corresponding cross-chain transaction payloads.
    
    \item \textbf{KeyManager:} A security-critical class responsible for managing the Guardian's private keys.
    \begin{itemize}
        \item Composition: The TxOrchestrator has a composition relationship with KeyManager, indicating that the orchestrator cannot function (cannot sign transactions) without the secure signing module.
    \end{itemize}
    
    \item \textbf{SolanaRelayer:} This class handles the low-level networking required to broadcast signed transactions to the Solana cluster and confirm their finality.
    \begin{itemize}
        \item Aggregation: The TxOrchestrator aggregates the SolanaRelayer, utilizing it as a service to dispatch the final outcome of its logic.
    \end{itemize}
\end{itemize}

\subsubsection{EVM Controller Package Design}
% \pgfdeclarelayer{background}
% \pgfdeclarelayer{foreground}
% \pgfsetlayers{background,main,foreground}

The EVM Controller Package is designed to manage user interactions on the EVM chains, ensuring that requests are properly formatted, signed, and validated before being relayed to the Solana Hub. This package adheres to a layered design within the EVM environment, separating concerns related to request handling, data validation, and asset management.

Figure \ref{fig:evm_detailed_design} illustrates the class structure within this package.

\begin{figure}[htbp]
    \centering
    \resizebox{\textwidth}{!}{
    \begin{tikzpicture}[
        node distance=2.5cm and 3.5cm, % Dọc = 2.5cm, Ngang = 3.5cm
        % --- STYLES ---
        uml_class/.style={
            draw, rectangle, 
            minimum width=4.5cm, minimum height=1.5cm, 
            align=center, 
            fill=gray!5, 
            font=\bfseries\large, 
            drop shadow={opacity=0.15},
            thick
        },
        % Style riêng cho Interface
        uml_interface/.style={
            draw, rectangle, % Viền đứt
            minimum width=4.5cm, minimum height=1.5cm, 
            align=center, 
            fill=white, % Nền trắng
            font=\bfseries\large, 
            drop shadow={opacity=0.15},
            thick
        },
        uml_package_style/.style={
            draw, rectangle, 
            inner sep=1cm, 
            fill=white, 
            drop shadow={opacity=0.2},
            rounded corners=2pt
        },
        uml_tab_style/.style={
            draw, rectangle, 
            fill=white, 
            minimum width=5cm, minimum height=1cm, 
            font=\bfseries\Large, 
            anchor=south west
        },
        % Quan hệ
        rel_impl/.style={-{Triangle[open, length=4mm, width=4mm]}, dashed, thick},
        rel_assoc/.style={-, thick}
    ]

        % 1. VẼ CÁC CLASS (Dùng positioning relative để tự động căn khoảng cách)
        
        % Class trung tâm
        \node[uml_class] (controller) {Controller Contract};
        
        % Interface nằm bên TRÁI Controller (cách 3.5cm)
        \node[uml_interface, left=of controller] (ireq) {<<Interface>> \\ IRequestHandler};
        
        % Verifier nằm bên PHẢI Controller (cách 3.5cm)
        \node[uml_class, right=of controller] (verifier) {SignatureVerifier};
        
        % Action nằm bên DƯỚI Controller (cách 2.5cm)
        \node[uml_class, below=of controller] (req_action) {RequestAction};

        % 2. VẼ CÁC ĐƯỜNG KẾT NỐI
        
        % (1) Controller implements Interface (Mũi tên chỉ về phía Interface)
        \draw[rel_impl] (controller) -- (ireq);
        
        % (2) Controller uses SignatureVerifier (Đường thẳng)
        \draw[rel_assoc] (controller) -- (verifier);
        
        % (3) Controller uses RequestAction (Đường thẳng)
        \draw[rel_assoc] (controller) -- (req_action);

        % 3. VẼ KHUNG PACKAGE (LAYER BACKGROUND)
        \begin{pgfonlayer}{background}
            % Fit bao gồm tất cả các node + padding
            \node[uml_package_style, fit=(ireq) (controller) (verifier) (req_action)] (pkg_box) {};
            
            % Vẽ Tab tên Package
            \node[uml_tab_style] at (pkg_box.north west) {pkg EVMController};
        \end{pgfonlayer}

    \end{tikzpicture}
    }
    \caption{Detailed Design of EVM Controller Package}
    \label{fig:evm_detailed_design}
\end{figure}

\textbf{Design Explanation:}
\begin{itemize}
    \item \textbf{Controller Contract:} This is the core contract deployed on the EVM chain. It manages user requests and orchestrates the cross-chain interaction flow.
    \begin{itemize}
        \item Interface Implementation: The contract implements the IRequestHandler interface, defining the standard methods for processing external requests.
        \item Usage Relationships: It has direct associations with RequestAction and SignatureVerifier classes. The Controller Contract utilizes RequestAction to structure and validate incoming request data and relies on SignatureVerifier to perform cryptographic checks on user signatures.
    \end{itemize}
    
    \item \textbf{RequestAction:} A data structure class that encapsulates all the necessary parameters for a cross-chain request (e.g., nonce, action type, amount, destination chain ID). It is used by the Controller Contract to hold and process incoming requests.
    
    \item \textbf{SignatureVerifier:} This utility class is responsible for validating the authenticity of a user's signature. It takes the message $M$ and the signature $\sigma$ as input and verifies if they were generated by the owner of the intended EVM address. This is a critical security component that prevents unauthorized actions.
\end{itemize}


% %%%%%%%%%%%
\section{Detailed Design}

This section presents the comprehensive design specification for the Multi-chain Stablecoin Protocol. It decomposes the system into three core layers: Smart Contract Design (On-chain), Server Application Design (Off-chain), and Database Design (Persistence). The level of detail provided herein serves as the blueprint for the implementation phase.

\subsection{Smart Contract Design}

The smart contract architecture serves as the immutable backbone of the Multi-chain Stablecoin Protocol. It is partitioned into two distinct environments: the EVM Controller (handling asset custody and user requests) and the Solana Hub (handling global state and core financial logic). The design focuses on data integrity, cryptographic security, and efficient state synchronization.

\subsubsection{EVM Controller Design}
The Controller contract, deployed on EVM-compatible networks, functions as the primary interface for user interaction and asset custody within the multi-chain ecosystem. Its design philosophy prioritizes security and simplicity, acting as a decentralized vault that locks collateral assets while delegating complex financial calculations to the central hub. The contract is architected to manage the lifecycle of user requests through a state machine model, ensuring that every cross-chain operation is atomic and reversible.

At the data level, the contract maintains a robust set of structures to track user positions and system integrity. Central to this design is the Request structure, which acts as a comprehensive data carrier. This structure encapsulates all necessary metadata for a transaction, including a unique request identifier, the destination chain identifier, and the specific action type such as deposit or withdrawal. Furthermore, it stores the cryptographic signature generated by the user, which serves as the immutable proof of intent required by the destination chain. To prevent replay attacks and ensure the strict ordering of operations, the contract implements a nonce management system, associating a monotonically increasing counter with each user address.

This is the data structures to manage the lifecycle of user requests:

\begin{itemize}
    \item Request Struct: This is the fundamental data unit representing a user's intent. It encapsulates all necessary information for cross-chain processing:
    \begin{itemize}
        \item requestId: A unique identifier for tracking the request across the system.
        \item chainId: The ID of the destination chain where the action should be executed.
        \item user: The EVM address of the user initiating the transaction.
        \item actionType: An enumeration defining the operation (Deposit, Withdraw, Mint, Burn).
        \item token: The address of the collateral token involved in the transaction.
        \item amount: The quantity of tokens to be processed.
        \item nonce: A sequential counter ensuring strict ordering and preventing replay attacks.
        \item deadline: A timestamp after which the request is considered invalid, protecting against delayed execution.
        \item signature: The cryptographic proof consisting of the components $(r, s, v)$, generated by the user's private key.
    \end{itemize}

    \item ActionType Enum: A predefined set of constants representing valid operations: Deposit, Withdraw, Mint, and Burn. This strict typing prevents invalid operations from being submitted.

    \item Link Wallet Request: A specialized structure used when a user wishes to link their EVM address to a Universal Wallet on a different chain. It stores the binding request until it is verified by the Solana Hub.
\end{itemize}

A critical aspect of the controller design is the concurrency control mechanism, implemented through a pessimistic locking strategy. When a user initiates a request, the contract enforces a mutex lock on their specific account state. This prevents the user from submitting multiple simultaneous requests, which could lead to race conditions or state desynchronization between the source and destination chains. The lock remains active until the off-chain guardian infrastructure explicitly confirms the finality of the operation on the remote chain. This design choice ensures linearizability, guaranteeing that the system state transitions occur in a predictable and secure sequence.

The operational logic of the contract is exposed through a restricted set of external functions. The primary entry point allows users to submit signed requests, triggering the asset transfer to the vault and the emission of an event log for off-chain listeners. Complementing this is the callback interface, accessible exclusively by the authenticated guardian address. This interface facilitates the finalization of the cross-chain lifecycle. Upon receiving a success signal from the guardian, the contract executes the final state transition, such as minting stablecoins to the user. Conversely, in the event of a remote failure, the contract provides a revert mechanism that releases the mutex lock and refunds the locked assets, ensuring that user funds are never permanently frozen due to network issues.

The contract exposes specific functions for User-System interaction and Guardian-System synchronization:

\begin{itemize}
    \item Request (User-Facing): This function is the entry point for users. When called, it validates the input parameters, transfers the user's assets to the contract vault (in case of Deposit), and emits an event. Crucially, it locks the user's nonce to prevent concurrent requests, ensuring linearizability.

    \item Complete Request (Guardian-Only): This restricted function is invoked by the Guardian server upon successful execution on the Solana Hub. It accepts the final status and, if successful, finalizes the local state (e.g., minting stablecoins to the user's wallet).

    \item Revert Request (Guardian-Only): Serving as a fail-safe mechanism, this function is called if the cross-chain operation fails on Solana (e.g., due to insufficient health factor). It unlocks the user's assets and resets the nonce, returning the system to its pre-request state without loss of funds.
\end{itemize}

\subsubsection{Solana Gateway Design}
The Gateway contract on the Solana network serves as the secure ingress point for all cross-chain traffic, acting as a cryptographic firewall between the external environment and the internal financial logic. Its primary design objective is to sanitize and authenticate incoming data payloads before they can influence the system's state. Unlike typical smart contracts that focus on business rules, the Gateway is specialized for high-performance data verification, leveraging the parallel processing capabilities of the Solana runtime.

Data ingestion within the Gateway is handled through a specialized storage structure designed to accommodate the heterogeneous data formats of EVM chains. Since Ethereum uses 256-bit integers while Solana native programs are optimized for 64-bit or 128-bit operations, the Gateway implements a data normalization layer. When the off-chain guardian submits a request, the contract parses the raw byte stream, validating the integrity of the data layout and converting the parameters into a format compatible with the system's internal logic. This normalization process ensures that subsequent module calls operate on clean, type-safe data structures, preventing serialization errors deep within the call stack.
There is one primary data structure within the Gateway:
\begin{itemize}
    \item Request Data Storage: The contract defines a specific data layout to store the re-formatted request received from the EVM chain. Unlike the EVM struct, this data is optimized for the Solana BPF runtime (e.g., converting 256-bit integers to 64/128-bit where applicable) to minimize storage costs.
\end{itemize}

The most critical function of the Gateway is the execution of cryptographic proofs. The contract exposes a specific instruction set that allows the authorized guardian to submit the user's original signature along with the message payload. Instead of implementing complex elliptic curve mathematics in user-space code, which would be prohibitively expensive in terms of compute units, the Gateway utilizes Solana's native Secp256k1 program. By performing a cross-program invocation to this precompiled utility, the contract can efficiently verify that the signature provided was indeed generated by the claimed EVM address. Only upon successful verification does the Gateway permit the control flow to proceed to the Main Contract, thereby establishing a trustless link between the user's identity on Ethereum and their actions on Solana.
The Gateway exposes the following key method for secure data handling:
\begin{itemize}
    \item Set Request (Guardian-Only): This instruction allows the authorized Guardian to submit the raw data and signature from the EVM chain. The method performs the heavy lifting of Secp256k1 signature verification to prove that the data originated from the claimed EVM user. Once verified, it formats the data into an internal instruction and invokes the Main Contract.
\end{itemize}

\subsubsection{Solana Main Contract Design}
The Main Contract functions as the central nervous system of the protocol, encapsulating the global financial state and executing the core logic of the Collateralized Debt Position mechanism. This component is architected to be the single source of truth for the entire multi-chain ecosystem, aggregating disparate asset data into a unified solvency model. The design prioritizes modularity and state isolation, ensuring that the complex interactions between collateral management, debt issuance, and liquidation are handled with precision and security.

At the heart of the state management strategy is the Universal Wallet, a sophisticated data structure stored as a Program Derived Address. This structure aggregates the user's entire portfolio, tracking the collateral balances deposited across various connected chains and the total debt issued by the protocol. By maintaining this global view, the contract can calculate a unified health factor for each user in real-time, allowing for capital efficiency that isolated lending protocols cannot match. Complementing individual user states is the Depository, a global singleton account that tracks system-wide parameters such as the total value locked, the aggregate debt ceiling, and the risk configurations for each supported asset class.
The Main Contract defines several critical data structures to manage user positions and system integrity:
\begin{itemize}
    \item Universal Wallet: The central PDA (Program Derived Address) that aggregates a user's entire portfolio. It stores the total collateral balance and total debt across all connected chains, serving as the single source of truth for solvency calculations.
    
    \item Depository: A global state tracking the system-wide parameters, such as total protocol debt, total value locked (TVL), and risk parameters (LTV ratios) for each supported asset.
    
    \item Loan: A data structure representing the specific debt position of a user. It tracks the principal amount borrowed and the accrued interest over time.
    
    \item Link Wallet Request: Stores pending requests for wallet linkage. When a user wants to control their Solana Universal Wallet from a new EVM address, this attribute temporarily holds the request until proof of ownership is established.
\end{itemize}

The operational logic of the contract is exposed through a set of polymorphic instructions capable of handling requests from diverse origins. Fundamental operations such as deposit, mint, and withdraw are designed to be agnostic to the caller's source. Whether the instruction originates from a native Solana user or is relayed by the Guardian on behalf of an EVM user, the underlying business logic remains consistent. This unification simplifies the codebase and reduces the attack surface. Additionally, the contract implements a specialized liquidation engine that runs natively on Solana. When a user's position becomes insolvent due to market volatility, this engine allows liquidators to repay debt and seize collateral directly on the hub chain, ensuring that the protocol remains solvent without relying on asynchronous cross-chain calls for critical risk management.
The Main Contract exposes the following key methods for user interaction and system maintenance:
\begin{itemize}
    \item Deposit, Mint, Burn, Withdraw: These are the fundamental CDP operations. They are designed to be polymorphic, capable of being invoked either by the Guardian (relaying an action from an EVM user) or directly by a Solana Native User. This unified interface ensures that the business logic remains consistent regardless of the user's origin chain.
    
    \item Interact Universal Wallet (Guardian-Only): A specialized administrative method allowing the Guardian to update the mapping within a Universal Wallet, such as adding a new linked chain address after successful verification.
    
    \item Liquidate: This critical function maintains system solvency. It is executed natively on the Solana chain. When a user's Health Factor drops below the threshold, a liquidator can call this method. The liquidator repays the user's debt (in stablecoins) directly on Solana and, in return, receives a portion of the user's collateral stored in the Solana vault (or claims rights to cross-chain collateral via the Depository).
\end{itemize}

\subsection{Server Application Design}

The Off-chain Infrastructure, architected as the Guardian Middleware, functions as the central nervous system of the protocol, facilitating the secure and reliable transmission of state between the EVM asset layer and the Solana execution layer. Implemented within a Node.js runtime environment, the server is designed not merely as a passive relay, but as an active orchestration engine capable of handling network instability, data verification, and state synchronization. The design of this application is comprehensive, addressing five critical functional domains: network connectivity, data persistence, business logic orchestration, cryptographic security, and transaction finality management.

The first critical function of the server is the robust ingestion of blockchain events through the Network Connectivity and Event Monitoring module. The application initializes and maintains persistent connections to multiple JSON-RPC providers for each supported chain. This multi-provider strategy is essential to mitigate the risk of single-point failures where a specific node provider might experience downtime or latency spikes. The event listener operates on a polling mechanism that queries the EVM Controller contract for specific logs, such as the request creation events. To ensure data integrity, the listener implements a block confirmation delay strategy, waiting for a configurable number of block confirmations before ingesting an event. This precaution is necessary to protect the system from interacting with reorganized blocks or chain forks, ensuring that the Guardian only acts upon immutable ledger states.

Once an event is securely ingested, the system relies on the Data Persistence and Reliability module to manage the asynchronous processing flow. Recognizing that cross-chain operations involve probabilistic latency, the server avoids in-memory processing which is volatile and prone to data loss during system restarts. Instead, all incoming requests are serialized and pushed into a persistent First-In-First-Out queue backed by the local file system or a dedicated database. This queuing mechanism serves as a buffer that decouples the high-throughput ingestion layer from the transaction submission layer. It allows the system to absorb traffic spikes without overwhelming the Solana RPC endpoints. Furthermore, this module integrates with a Redis key-value store to implement idempotency checks. By caching the unique nonce of every processed request, the system ensures that a specific user action is never executed twice, even if the source chain emits duplicate events due to network retries.

Following the queuing phase, the Business Logic Orchestration module takes responsibility for interpreting and transforming the raw data. Since the EVM and Solana environments utilize different data standards—for instance, the handling of large integers and address formats—this module performs the necessary normalization. It parses the binary payload from the EVM logs, extracting critical parameters such as the user identity, token address, and action type. The logic then maps these parameters to the corresponding Solana-specific data structures defined in the Anchor program IDL. This phase also involves the validation of business rules off-chain, such as checking if the user's request exceeds the system's global debt ceiling or if the requested token is currently supported by the protocol. This pre-computation layer reduces the burden on the on-chain smart contracts, ensuring that only structurally valid transactions are attempted.

Integral to the safety of the protocol is the Cryptographic Security and Verification module. Before the Guardian constructs a transaction to update the state on the Solana Hub, it must cryptographically prove that the request originated from the rightful owner. The server implements a signature verification utility that reconstructs the message hash from the request parameters and performs an elliptic curve recovery on the user's provided signature. This off-chain verification acts as a filter to discard malicious or forged requests immediately, saving the Guardian from paying gas fees for invalid transactions. Additionally, this module manages the Guardian's own sensitive private keys through a secure Key Management System. The signing process is isolated from the logic layer, ensuring that the private keys are never exposed in logs or memory dumps, strictly adhering to the principle of least privilege.

The final functional component is the Transaction Dispatch and State Synchronization module, which closes the feedback loop of the cross-chain interaction. After constructing and signing the Solana transaction, this module broadcasts it to the cluster and enters an observation state. Unlike standard "fire-and-forget" mechanisms, this system implements a sophisticated polling logic to track the transaction's lifecycle until it reaches a finalized status. Upon confirmation of the execution result on Solana, the module constructs a corresponding callback transaction directed back to the EVM Controller. This callback carries the success or failure status, triggering the asset layer to either mint the stablecoins or revert the locked collateral. This bidirectional synchronization ensures that the distributed system maintains eventual consistency, preventing any scenario where user funds remain indefinitely locked in transit due to partial failures.

\subsection{Database Design}

While the blockchain ledger serves as the immutable system of record, the architecture incorporates an off-chain database layer within the Guardian infrastructure. This database functions as a high-performance indexer and state cache, facilitating rapid data retrieval for the frontend interface and supporting complex queries required for the liquidation engine. The schema is designed to mirror the on-chain state, organized into three primary domains: Identity Management, User Position Tracking, and Protocol Liquidity Control.

\subsubsection{Universal Wallet Collection}
The fundamental entity within the database is the Universal Wallet collection, which manages the cross-chain identity mapping. The primary objective of this entity is to prevent identity collisions and enforce the one-to-one relationship between a user's primary EVM address and their Solana Program Derived Address. The schema for this entity stores the unique Universal Wallet address derived from the Solana blockchain, acting as the primary key. Associated with this key is the Owner field, recording the initial EVM address that created the position. To support multi-chain interoperability, the entity includes a Wallets array or relation, listing all secondary addresses from different chains that have been cryptographically linked to this profile. This structure allows the Guardian to instantly verify if an incoming request originates from an authorized address associated with an existing universal profile, thereby preventing duplicate wallet creation attempts.
The Universal Wallet collection includes the following key attributes:
\begin{itemize}
    \item \textbf{Universal wallet address (Primary Key):} The unique Solana address (PDA) generated by the program. This serves as the global identifier for the user's account across the entire system.
    \item \textbf{Owner address:} The initial EVM address that created the wallet. This field is used to authenticate the root ownership rights.
    \item \textbf{Linked wallets:} An array or relational table storing all secondary EVM addresses linked to this Universal Wallet. This allows the system to recognize a user interacting from different chains (e.g., Polygon, BSC) as the same entity.
    \item \textbf{Creation tx hash:} The transaction hash on the source chain that triggered the wallet creation. This serves as an immutable audit trail for the account's origin.
    \item \textbf{Status:} A status flag (e.g., \textit{Active, Pending Sign, Blacklisted}) used to manage the operational state of the wallet.
\end{itemize}

\subsubsection{User Collection (Loans and Requests)}
The second critical domain is the User Position and Transaction History, which tracks the financial health and interaction logs of individual users. This domain is essential for both the user dashboard and the automated liquidation bots. The User entity aggregates the financial data, storing the Loan details such as total minted debt and the current composite collateral value. Crucially, it maintains a computed Health Factor field, updated in real-time based on oracle price feeds, which allows the system to query for under-collateralized positions efficiently without scanning the entire blockchain. Linked to the user profile is the Transaction Requests collection. This entity logs every lifecycle event, capturing attributes such as the request ID, action type, token amount, and the associated transaction hashes for both the source and destination chains. This historical log serves as an audit trail, enabling the system to track the status of asynchronous cross-chain operations and detect any stuck or failed requests that require manual intervention.
The User Collection encompasses two main sub-entities:
\begin{itemize}
    \item \textbf{Loan Position State:}
    \begin{itemize}
        \item \textbf{Total debt:} The aggregate amount of stablecoins minted by the user, denominated in the protocol's base unit.
        \item \textbf{Total collateral value:} The real-time USD value of all assets locked by the user across all chains. This is frequently updated by the price oracle workers.
        \item \textbf{Health factor:} A computed index derived from the \eqref{eq:health_factor_global} formula. This field is indexed to allow liquidator bots to query where Health factor < 1.0 efficiently.
        \item \textbf{Liquidation threshold:} The minimum safe ratio required for the specific basket of assets held by the user.
    \end{itemize}
    \item \textbf{Request Action History:}
    \begin{itemize}
        \item \textbf{Request id:} A unique composite key (typically chainId + nonce) identifying a specific user action.
        \item \textbf{Action type:} Specifies the intent of the transaction (e.g., \textit{Deposit, Withdraw, Mint, Repay}).
        \item \textbf{Source chain id} \& \textbf{Dest chain id}: Tracks the origin and destination networks of the request.
        \item \textbf{Token address} \& \textbf{Amount}: Details the asset and quantity involved in the transaction.
        \item \textbf{EVM tx hash:} The transaction hash on the EVM side (Locking/Burning assets).
        \item \textbf{Solana tx hash:} The corresponding transaction hash on the Solana side (State Update). This links the two asynchronous events together.
        \item \textbf{Process status:} Indicates the current lifecycle stage: \textit{Pending, Processing, Completed, Failed, Reverted}.
    \end{itemize}
\end{itemize}

\subsubsection{Controller \& Liquidity Collection}
Finally, the Protocol Controller domain manages the aggregate liquidity and security parameters of the system. This entity tracks the global state of the protocol across all connected spokes. It records the Total Value Locked (TVL) per chain and the total circulating supply of the stablecoin. The schema includes specific fields for liquidity management, monitoring the available capacity of each EVM vault to ensure that withdrawal requests can be honored. Furthermore, this domain stores system-wide configuration parameters, such as the current Loan-To-Value ratios for supported collateral assets and the operational status of each bridge connection. By centralizing this data off-chain, the Guardian can perform complex analytics to detect liquidity imbalances or potential security threats, allowing for proactive rebalancing or emergency pausing of specific controller contracts if anomalies are detected.
The Controller \& Liquidity Collection includes the following critical attributes:
\begin{itemize}
    \item \textbf{Chain id:} The identifier for the specific blockchain network (e.g., 1 for Ethereum).
    \item \textbf{Total value locked (TVL):} The aggregate amount of collateral assets currently held in the protocol on each specific chain.
    \item \textbf{Circulating supply:} The total amount of stablecoins minted and currently active in the market from each chain.
    \item \textbf{Available liquidity:} Monitors the free capital available in the vault. This is crucial for approving withdrawal requests; if a vault is empty, the Guardian must pause withdrawals or trigger a rebalance.
\end{itemize}

\section{Application Client}

This section demonstrates the implementation of the client-side application, focusing on the user experience flows for identity management and cross-chain financial operations.

\subsection{User Interface for Universal Wallet}

The Universal Wallet interface serves as the foundational layer of the application, enabling users to aggregate their fragmented blockchain identities into a single manageable profile. This interface handles the complexities of multi-chain authentication and state synchronization.

\subsubsection{Wallet Connectivity}

The initial interaction with the protocol begins with the wallet connection module. To support the hybrid architecture, the interface is designed to accommodate distinct blockchain standards simultaneously. The connectivity panel categorizes providers into specific network groups, allowing users to select between Solana-native wallets like Phantom or EVM-compatible wallets such as MetaMask. A distinguishing feature of this implementation is the support for concurrent multi-wallet connections. Users can maintain active sessions with multiple providers at the same time, which is visualized by the status indicators next to each provider. This capability is essential for the protocol, as it allows the application to read balances and request signatures from different chains without forcing the user to constantly switch the active network in their browser extension.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.7\textwidth]{Figure/wl_connect_client.png}
    \caption{Multi-chain Wallet Connectivity Interface}
    \label{fig:wl_connect}
\end{figure}

\subsubsection{Link Wallet Workflow}

Once the wallets are connected, the user interacts with the linking interface to establish the Universal Wallet. The design presents a dual-field form requiring the selection of a source wallet and a destination wallet. The application enforces a rigorous proof-of-ownership protocol during this process. The workflow initiates when the user selects the request option, triggering a transaction on the source chain. This on-chain action serves as the intent declaration. Upon successful confirmation of the source transaction, the interface automatically prompts the user to sign a cryptographically secure message using the destination wallet. This two-step verification ensures that the link is established only when the user possesses the private keys for both addresses, effectively binding the identities across the two networks.

There is one primary screen for the Universal Wallet, as shown in Figure \ref{fig:universal_wl}. The interface is divided into two main panels: the wallet connectivity panel on the left and the wallet management panel on the right.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1.0\textwidth]{Figure/universal_wl_client.png}
    \caption{Universal Wallet Management Interface (Link and List View)}
    \label{fig:universal_wl}
\end{figure}

\subsubsection{Remove Wallet Logic}

The management of associated addresses is handled through the wallet list panel, where users can view and disassociate their linked accounts. The interface provides a removal function for each entry; however, the execution of this action is governed by strict logic to preserve system integrity. The protocol distinguishes between the primary wallet, which acts as the root identifier, and secondary wallets. The interface restricts the removal of the first wallet, enforcing a rule that it can only be dissociated after all secondary wallets have been removed. Additionally, the system performs a solvency check before allowing any removal operation. If the user has outstanding debt obligations, the interface prevents the removal of any wallet that contains collateral necessary to maintain a safe health factor, thereby securing the protocol against under-collateralization risks.

\subsection{User Interface for Cross-chain Borrow}

The borrowing interface acts as the central command center for the user's financial activities. It is designed to provide immediate visual feedback on the user's solvency while offering granular control over their asset allocation across different chains. Figure \ref{fig:borrow_client} illustrates the consolidated dashboard view.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.95\textwidth]{Figure/borrow_client.png}
    \caption{Cross-chain Borrowing and Position Management Interface}
    \label{fig:borrow_client}
\end{figure}

\subsubsection{Overview Panel: Total Deposit and Minted}
At the top of the interface, the system aggregates the user's global financial position into two primary metrics: Total Deposited and Total Minted. Unlike single-chain applications that only show local balances, these values represent the summation of assets across all connected networks (e.g., Ethereum, Solana, Arbitrum), normalized to a USD base currency. This high-level summary provides users with an instant snapshot of their portfolio's scale and their outstanding liabilities, which is crucial for making informed borrowing decisions. To the right, the current Borrow Rate is prominently displayed, ensuring transparency regarding the cost of debt.

\subsubsection{Action Panel: Deposit and Mint Operations}
The core interaction occurs within the dual-pane action modules for Deposit and Mint. 
\begin{itemize}
    \item \textbf{Deposit Module:} This component allows users to lock collateral. It features a chain-agnostic token selector, enabling the user to deposit assets like USDC or ETH from any supported network without leaving the dashboard. The interface automatically fetches the user's available balance and provides a "Max" button for convenience.
    \item \textbf{Mint Module:} Correspondingly, the minting module allows the user to generate the protocol's stablecoin (USDAI) on any s. It is tightly coupled with the deposit module; as the user inputs a deposit amount, the interface dynamically updates the borrowing capacity in the mint section, providing real-time feedback on how much debt can be safely issued against the new collateral.
\end{itemize}

\subsubsection{Risk Management Controls: LTV and Health Factor}
To mitigate the risk of liquidation, the interface incorporates advanced visualization tools for risk management.

\textbf{Loan-To-Value (LTV) Slider:}
A distinctive feature of the design is the interactive LTV slider bar. This control visualizes the ratio between the minted value and the collateral value. As users adjust the amount of debt they wish to mint, the progress bar fills up towards the liquidation threshold (marked in red at 98\%). This visual cue helps users intuitively understand their position's risk level relative to the maximum allowable limit (95\%), preventing accidental over-leveraging.

\textbf{Health Factor Gauge:}
The Health Factor is the most critical metric for position safety, and it is visualized using a semi-circular gauge. The interface categorizes the health status into color-coded zones: red for danger (close to 1.0), yellow for caution, and green for healthy (e.g., $> 1.5$). In the example shown, a Health Factor of 1.92 indicates a robust position. This gauge updates instantaneously as the user modifies the deposit or mint amounts in the action panel, allowing them to simulate the impact of their transaction on their solvency before committing to the blockchain.

\textit{[Content to be added]}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1.0\textwidth]{Figure/borrow_client.png}
    \caption{Cross-chain Borrowing Interface}
    \label{fig:borrow_client}
\end{figure}

\subsection{User Interface for Portfolio}

\textit{[Content to be added]}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1.0\textwidth]{Figure/portfolio_client.png}
    \caption{User Portfolio and Position Management}
    \label{fig:portfolio_client}
\end{figure}

\section{Application Building}
\subsection{Libraries and Tools}
Sinh viên liệt kê các công cụ, ngôn ngữ lập trình, API, thư viện, IDE, công cụ kiểm thử, v.v. mà mình sử dụng để phát triển ứng dụng. Mỗi công cụ phải được chỉ rõ phiên bản sử dụng. SV nên kẻ bảng mô tả tương tự như Bảng \ref{table:my_label}. Nếu có nhiều nội dung trình bày, sinh viên cần xoay ngang bảng.

\begin{table}[H]
\centering{}
    \begin{tabular}{lll}
        \hline
        \textbf{Mục đích} & \textbf{Công cụ}       & \textbf{Địa chỉ URL}    \\ \hline
        IDE lập trình     & Eclipse Oxygen a64 bit & http://www.eclipse.org/ \\ \hline
        v.v.              & v.v.                   & v.v.                    \\ \hline
        \end{tabular}
    \caption{Danh sách thư viện và công cụ sử dụng}
    \label{fig:my_label}
\end{table}

\subsection{Achievement}
Sinh viên trước tiên mô tả kết quả đạt được của mình là gì, ví dụ như các sản phẩm được đóng gói là gì, bao gồm những thành phần nào, ý nghĩa, vai trò?

Sinh viên cần thống kê các thông tin về ứng dụng của mình như: số dòng code, số lớp, số gói, dung lượng toàn bộ mã nguồn, dung lượng của từng sản phẩm đóng gói, v.v. Tương tự như phần liệt kê về công cụ sử dụng, sinh viên cũng nên dùng bảng để mô tả phần thông tin thống kê này.

\subsection{Illustration of main functions}
Sinh viên lựa chọn và đưa ra màn hình cho các chức năng chính, quan trọng, và thú vị nhất. Mỗi giao diện cần phải có lời giải thích ngắn gọn. Khi giải thích, sinh viên có thể kết hợp với các chú thích ở trong hình ảnh giao diện.

\section{Testing}
Phần này có độ dài từ hai đến ba trang. Sinh viên thiết kế các trường hợp kiểm thử cho hai đến ba chức năng quan trọng nhất. Sinh viên cần chỉ rõ các kỹ thuật kiểm thử đã sử dụng. Chi tiết các trường hợp kiểm thử khác, nếu muốn trình bày, sinh viên đưa vào phần phụ lục.
Sinh viên sau cùng tổng kết về số lượng các trường hợp kiểm thử và kết quả kiểm thử. Sinh viên cần phân tích lý do nếu kết quả kiểm thử không đạt.
\section{Deployment}
Sinh viên trình bày mô hình và/hoặc cách thức triển khai thử nghiệm/thực tế. Ứng dụng của sinh viên được triển khai trên server/thiết bị gì, cấu hình như thế nào. Kết quả triển khai thử nghiệm nếu có (số lượng người dùng, số lượng truy cập, thời gian phản hồi, phản hồi người dùng, khả năng chịu tải, các thống kê, v.v.)

\end{document}
