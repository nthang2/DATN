\documentclass[../Main.tex]{subfiles}
\begin{document}

\tikzset{
    % Style cho Package (Khung bao ngoài)
    uml_package/.style={
        draw, rectangle, 
        minimum width=12cm, minimum height=8cm, 
        anchor=north, 
        fill=white, 
        drop shadow={opacity=0.3}
    },
    % Style cho Tab tên Package
    uml_package_tab/.style={
        draw, rectangle, 
        fill=white, 
        minimum width=3.5cm, minimum height=0.7cm, 
        font=\bfseries
    },
    % Style cho Class
    uml_class/.style={
        draw, rectangle, 
        minimum width=3.2cm, minimum height=1.2cm, 
        align=center, 
        fill=gray!5, 
        font=\bfseries\small,
        drop shadow={opacity=0.15}
    },
    % --- ĐỊNH NGHĨA QUAN HỆ UML (Sử dụng arrows.meta) ---
    % 1. Implementation (Thực thi/Hiện thực hóa): Nét đứt, đầu tam giác rỗng
    rel_implementation/.style={-{Triangle[open, length=3mm, width=3mm]}, dashed, thick},
    % 2. Aggregation (Kết tập): Đầu hình thoi trắng (rỗng)
    rel_aggregation/.style={{Diamond[open, length=3mm, width=3mm]}-, thick},
    % 3. Composition (Hợp thành): Đầu hình thoi đen (đặc)
    rel_composition/.style={{Diamond[fill=black, length=3mm, width=3mm]}-, thick},
    % 4. Association (Kết hợp): Đường thẳng
    rel_association/.style={-, thick}
}


\section{Architecture Design}

\subsection{Overall design}

The architectural design of the Multi-chain Stablecoin Protocol is founded upon a Hybrid Event-Driven Microservices framework, structured within a Hub-and-Spoke topology. This sophisticated architecture is engineered to resolve the inherent challenges of liquidity fragmentation and state synchronization across heterogeneous blockchain networks. By strictly decoupling the Asset Custody Layer (residing on EVM chains) from the State Execution Layer (residing on the Solana SVM), the system achieves a high-performance, scalable solution that leverages the distinct advantages of each blockchain environment.

The architecture is composed of three primary execution environments, each functioning as an autonomous system component yet interconnected through a secure event-driven pipeline. The first environment is the EVM Spoke, which hosts the Controller Contract. This contract functions as the user's primary interface and asset vault, designed to be lightweight and gas-efficient. Its responsibilities are strictly limited to asset locking, event emission, and state updates based on authorized callbacks. The second environment is the Solana Hub (SVM), which acts as the system's "Brain." It hosts the Gateway Contract for cryptographic verification and data formatting, and the Main Contract for executing the core business logic, such as managing the Universal Wallet and calculating dynamic Health Factors. The third environment, bridging the deterministic worlds of these blockchains, is the Off-chain Guardian Infrastructure. This middleware operates as an active listener and orchestrator, ensuring that state transitions on one chain are accurately and securely reflected on the other.

To visualize the interaction between these components and the directional flow of data, Figure \ref{fig:overall_arch} presents the detailed system architecture diagram.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.95\textwidth]{Figure/Overall_architecture.png}
    \caption{Detailed Architecture of the Multi-chain Stablecoin Protocol}
    \label{fig:overall_arch}
\end{figure}


The operational workflow of the system, as depicted in the diagram, follows a rigorous six-step process designed to ensure atomicity, security, and eventual consistency.

\paragraph{Step 1: Initiation and Request Encapsulation}
The process begins on the EVM chain where the user intends to perform an action, such as depositing collateral. The user constructs a message $M$ containing the action parameters (e.g., Token Address, Amount, Target Chain ID) and a unique nonce. Crucially, the user signs this message with their EVM private key, generating a signature $\sigma$. The user then submits a transaction to the \textbf{Controller Contract}. Upon receipt, the Controller does not immediately execute the cross-chain logic but performs two critical local actions: it locks the user's assets (in a Vault) and emits a `RequestCreated` event containing the message $M$ and signature $\sigma$. This emission acts as a signal flare to the off-chain infrastructure.

\paragraph{Step 2: Event Ingestion (The Listening Phase)}
Unlike traditional polling mechanisms that can be resource-intensive, the Guardian Server employs a reactive Event Listening model. It maintains an active WebSocket or HTTP connection to the EVM RPC nodes. When the `RequestCreated` event is emitted by the Controller, the Guardian immediately captures the log data. This step represents the "Event" in the Event-Driven Architecture. The Guardian parses the log to extract the raw data necessary for the state transition on the destination chain.

\paragraph{Step 3: Relaying and Submission}
Once the data is captured, the Guardian packages the original message $M$ and the signature $\sigma$ into a new transaction payload compatible with the Solana runtime. It then submits this transaction to the \textbf{Gateway Contract} on the SVM. In this phase, the Guardian acts strictly as a courier (Relayer); it does not modify the message content, ensuring that the user's original intent remains tamper-proof. The Guardian also manages the payment of SOL gas fees, abstracting the complexity of holding multiple native tokens from the end-user.

\paragraph{Step 4: Verification and Instruction Execution}
The \textbf{Gateway Contract} serves as the entry point to the Solana environment. Its primary responsibility is security. Before any business logic is executed, the Gateway invokes Solana's native `Secp256k1` program to cryptographically verify that the signature $\sigma$ corresponds to the user's EVM address contained in message $M$. This verification is performed on-chain, providing a trustless guarantee of identity. Upon successful verification, the Gateway formats the data into a structured Instruction and calls the \textbf{Main Contract}. The Main Contract then executes the core logic, such as creating a Universal Wallet PDA or updating the user's debt position.

\paragraph{Step 5: Outcome Observation}
Similar to the ingestion phase on the EVM side, the Guardian Server also maintains a listener on the Solana Blockchain. When the Main Contract finishes execution, it emits a specific event - either `ExecutionSuccess` (indicating the state was updated) or `ExecutionFailure` (indicating a logic error, such as low health factor). The Guardian listens for these specific outcome events to determine the final status of the cross-chain operation. This asynchronous confirmation step is vital for handling the probabilistic finality of blockchain networks.

\paragraph{Step 6: State Synchronization and Finalization}
Based on the event received from the Solana Main Contract, the Guardian initiates a final callback transaction to the EVM \textbf{Controller Contract} to close the loop. If the Solana execution was successful, the Guardian calls the `updateState` function to finalize the process (e.g., minting stablecoins to the user). If the Solana execution failed, the Guardian triggers a rollback mechanism, unlocking the user's assets and resetting their nonce. This ensures that the system maintains data consistency between the Asset Layer and the State Layer, preventing any funds from being permanently locked in transit.

\subsection{Detailed Package Design}

Based on the overall architecture, this section details the internal design of the critical subsystems. The design is visualized using Class Diagrams grouped by their respective execution environments.

\subsubsection{Solana Hub Package Design}
The Solana Hub Package, designated as package SolanaCore, encapsulates the system's central business logic and state management. This package is architected to ensure strict separation between the interface layer (Gateway), the logic layer (Main Contract and Managers), and the data layer (Wallet and Counters).
Figure \ref{fig:solana_detailed_design} illustrates the internal structure and class relationships within this package.

\pgfdeclarelayer{background}
\pgfdeclarelayer{foreground}
\pgfsetlayers{background,main,foreground}
\begin{figure}[htbp]
    \centering
    % Resizebox giúp hình to hết khổ giấy mà không bị tràn
    \resizebox{\textwidth}{!}{
    \begin{tikzpicture}[
        node distance=2.5cm,
        % --- STYLES ---
        uml_class/.style={
            draw, rectangle, 
            minimum width=4.5cm, minimum height=1.5cm, 
            align=center, 
            fill=gray!5, 
            font=\bfseries\large, % Font chữ to hơn
            drop shadow={opacity=0.15},
            thick
        },
        uml_package_style/.style={
            draw, rectangle, 
            inner sep=1cm, 
            fill=white, 
            drop shadow={opacity=0.2},
            rounded corners=2pt
        },
        uml_tab_style/.style={
            draw, rectangle, 
            fill=white, 
            minimum width=5cm, minimum height=1cm, 
            font=\bfseries\Large, 
            anchor=south west
        },
        % Quan hệ UML
        rel_impl/.style={-{Triangle[open, length=4mm, width=4mm]}, dashed, thick},
        rel_agg/.style={{Diamond[open, length=4mm, width=4mm]}-, thick},
        rel_comp/.style={{Diamond[fill=black, length=4mm, width=4mm]}-, thick},
        rel_assoc/.style={-, thick}
    ]

        % 1. VẼ CÁC CLASS (NODE) TRƯỚC
        
        % Hàng 1: Gateway ở giữa
        \node[uml_class] (gateway) at (0, 0) {GatewayContract};
        
        % Mở rộng khoảng cách sang 2 bên (x = -7 và x = 7)
        \node[uml_class] (formatter) at (-7.5, 0) {FormaterData};
        \node[uml_class] (verifier) at (7.5, 0) {SignatureVerifier};
        
        % Hàng 2: MainContract (Cách xa hơn chút)
        \node[uml_class] (main) at (0, -3.5) {MainContract};
        
        % Hàng 3: Position và Wallet (Mở rộng cân đối)
        \node[uml_class] (pos_mgmt) at (-7.5, -7) {PositionManagement};
        \node[uml_class] (wallet) at (7.5, -7) {UniversalWallet};
        \node[uml_class] (liq_mgmt) at (0, -10.5) {LiquidityManagement};
        
        % Hàng 4: NonceCounter (Nằm hẳn xuống dưới)
        \node[uml_class] (nonce) at (7.5, -10.5) {NonceCounter};

        % 2. VẼ CÁC ĐƯỜNG KẾT NỐI (RELATIONSHIPS)
        
        % (1) Implementation: Gateway -> Helper classes
        \draw[rel_impl] (gateway) -- (verifier);
        \draw[rel_impl] (gateway) -- (formatter);
        
        % (2) Aggregation: Gateway <>- MainContract
        \draw[rel_agg] (gateway) -- (main);
        
        % (3) Implementation: Main -> Position
        % Vẽ đường vuông góc đẹp
        \draw[rel_impl] (main.west) -| (pos_mgmt.north);
        
        % (4) Association: Main - Wallet
        \draw[rel_assoc] (main.east) -| (wallet.north);
        
        % (5) Association: Position - Wallet
        \draw[rel_assoc] (pos_mgmt) -- (wallet);
        
        % (6) Composition: Wallet *-- Nonce
        % Vẽ trực tiếp thẳng xuống
        \draw[rel_comp] (wallet) -- (nonce);

        \draw[rel_impl] (main) -- (liq_mgmt);

        % 3. VẼ KHUNG PACKAGE (NẰM Ở LAYER BACKGROUND)
        % Điều này đảm bảo khung không bao giờ che mất class
        \begin{pgfonlayer}{background}
            % Fit bao gồm tất cả các node biên
            \node[uml_package_style, fit=(formatter) (verifier) (nonce) (pos_mgmt) (gateway)] (pkg_box) {};
            
            % Vẽ Tab tên Package
            \node[uml_tab_style] at (pkg_box.north west) {pkg SolanaCore};
        \end{pgfonlayer}

    \end{tikzpicture}
    }
    \caption{Detailed Design of Solana Hub Package}
    \label{fig:solana_detailed_design}
\end{figure}

\textbf{Class Descriptions and Relationships:}
\begin{itemize}
\item \textbf{GatewayContract:} This class acts as the single entry point for all cross-chain transactions initiated by the Guardian. It serves as an orchestrator that sanitizes inputs before passing control to the core logic.
    \begin{itemize}
        \item Implementation Relationships: The Gateway implements logic from Formater Data class to deserialize incoming payloads and utilizes the Signature Verifier to perform cryptographic checks (Secp256k1 recovery) on the user's signature.
        \item Aggregation: It maintains an aggregation relationship with the Main Contract, indicating that the Gateway coordinates the execution flow but delegates the actual financial state transitions to the Main Contract.
    \end{itemize}
\item \textbf{MainContract:} This is the core controller of the system. It manages the lifecycle of CDPs and coordinates liquidity across chains. To maintain modularity, it splits complex operations into specialized management modules:
    \begin{itemize}
        \item It implements the Position Management module to handle collateral locking, debt minting, and health factor calculations.
        \item It implements the Liquidity Management module to handle the rebalancing of assets between the Hub and Spokes during liquidations.
    \end{itemize}

\item \textbf{UniversalWallet:} This class represents the persistent state (Program Derived Address - PDA) of a user. It stores the aggregated data of collateral and debt.
    \begin{itemize}
        \item Association: Both the Main Contract and Position Management have direct associations with the Universal Wallet to read and modify the user's financial position.
    \end{itemize}

\item \textbf{NonceCounter:} This class tracks the sequence number of transactions to prevent replay attacks.
    \begin{itemize}
        \item Composition: The diagram defines a strict composition relationship (filled diamond) between Universal Wallet and Nonce Counter. This implies that the Nonce Counter is an intrinsic part of the Wallet; it cannot exist independently, and its lifecycle is bound to the existence of the Universal Wallet.
    \end{itemize}
\end{itemize}

\subsubsection{Guardian Middleware Package Design}
The Guardian Middleware Package, designated as package GuardianService, acts as the off-chain orchestration layer. It is designed using an Event-Driven architecture to handle the asynchronous nature of cross-chain communication reliably.

Figure \ref{fig:guardian_detailed_design} depicts the internal class design of the Guardian node.

\begin{figure}[htbp]
    \centering
    \resizebox{\textwidth}{!}{
    \begin{tikzpicture}[
        node distance=2.5cm,
        % --- STYLES (Dùng lại style chuẩn của hình trước) ---
        uml_class/.style={
            draw, rectangle, 
            minimum width=4.5cm, minimum height=1.5cm, 
            align=center, 
            fill=gray!5, 
            font=\bfseries\large, 
            drop shadow={opacity=0.15},
            thick
        },
        uml_package_style/.style={
            draw, rectangle, 
            inner sep=1cm, 
            fill=white, 
            drop shadow={opacity=0.2},
            rounded corners=2pt
        },
        uml_tab_style/.style={
            draw, rectangle, 
            fill=white, 
            minimum width=5cm, minimum height=1cm, 
            font=\bfseries\Large, 
            anchor=south west
        },
        % Quan hệ UML
        rel_impl/.style={-{Triangle[open, length=4mm, width=4mm]}, dashed, thick}, % Thực thi / Phụ thuộc
        rel_agg/.style={{Diamond[open, length=4mm, width=4mm]}-, thick}, % Kết tập
        rel_comp/.style={{Diamond[fill=black, length=4mm, width=4mm]}-, thick}, % Hợp thành
        rel_assoc/.style={-, thick} % Kết hợp
    ]

        % 1. VẼ CÁC CLASS (NODE)
        
        % Trung tâm: EventQueue (Hàng đợi)
        \node[uml_class] (queue) at (0, 0) {EventQueue};
        
        % Bên Trái: Listener và Interface RPC
        \node[uml_class] (listener) at (-6, 0) {EventListener};
        \node[uml_class] (rpc) at (-6, 3.5) {<<Interface>>\\IRpcProvider};
        
        % Bên Phải: Orchestrator (Bộ điều phối)
        \node[uml_class] (orchestrator) at (6, 0) {TxOrchestrator};
        
        % Bên Dưới: Các thành phần hỗ trợ cho Orchestrator
        \node[uml_class] (signer) at (3.5, -4) {KeyManager};
        \node[uml_class] (relayer) at (8.5, -4) {SolanaRelayer};

        % 2. VẼ CÁC ĐƯỜNG KẾT NỐI
        
        % (1) Implementation: EventListener dùng IRpcProvider
        \draw[rel_impl] (listener) -- (rpc);
        
        % (2) Association: Listener đẩy vào Queue (Mũi tên ngang)
        \draw[rel_assoc] (listener) -- (queue);
        
        % (3) Association: Orchestrator lấy từ Queue
        \draw[rel_assoc] (queue) -- (orchestrator);
        
        % (4) Composition: Orchestrator sở hữu KeyManager (Bắt buộc phải có để ký)
        % Orchestrator *-- KeyManager
        \draw[rel_comp] (orchestrator.south) -- ++(0,-1) -| (signer.north);
        
        % (5) Aggregation: Orchestrator dùng SolanaRelayer (Để gửi tx)
        % Orchestrator <>- SolanaRelayer
        \draw[rel_agg] (orchestrator.south) -- ++(0,-1) -| (relayer.north);

        % 3. VẼ KHUNG PACKAGE (LAYER BACKGROUND)
        \begin{pgfonlayer}{background}
            % Fit bao gồm tất cả các node
            \node[uml_package_style, fit=(rpc) (listener) (relayer) (signer)] (pkg_box) {};
            % Vẽ Tab tên Package
            \node[uml_tab_style] at (pkg_box.north west) {pkg GuardianService};
        \end{pgfonlayer}

    \end{tikzpicture}
    }
    \caption{Detailed Design of Guardian Middleware Package}
    \label{fig:guardian_detailed_design}
\end{figure}

\textbf{Class Descriptions and Relationships:}

\begin{itemize}
    \item \textbf{EventListener:} This component is responsible for monitoring blockchain networks. It implements the IRpcProvider interface to maintain agnostic connections to various EVM chains (Ethereum, BSC, Arbitrum). Its primary role is to detect RequestCreated logs and normalize them into a standard event format.
    
    \item \textbf{EventQueue:} Acting as a buffer, this class decouples the ingestion layer (Listener) from the processing layer (Orchestrator). It ensures that during high network traffic, events are not lost but queued for sequential processing.
    
    \item \textbf{TxOrchestrator:} This is the core logic unit of the middleware. It consumes events from the queue, validates the data integrity, and constructs the corresponding cross-chain transaction payloads.
    
    \item \textbf{KeyManager:} A security-critical class responsible for managing the Guardian's private keys.
    \begin{itemize}
        \item Composition: The TxOrchestrator has a composition relationship with KeyManager, indicating that the orchestrator cannot function (cannot sign transactions) without the secure signing module.
    \end{itemize}
    
    \item \textbf{SolanaRelayer:} This class handles the low-level networking required to broadcast signed transactions to the Solana cluster and confirm their finality.
    \begin{itemize}
        \item Aggregation: The TxOrchestrator aggregates the SolanaRelayer, utilizing it as a service to dispatch the final outcome of its logic.
    \end{itemize}
\end{itemize}

\subsubsection{EVM Controller Package Design}
% \pgfdeclarelayer{background}
% \pgfdeclarelayer{foreground}
% \pgfsetlayers{background,main,foreground}

The EVM Controller Package is designed to manage user interactions on the EVM chains, ensuring that requests are properly formatted, signed, and validated before being relayed to the Solana Hub. This package adheres to a layered design within the EVM environment, separating concerns related to request handling, data validation, and asset management.

Figure \ref{fig:evm_detailed_design} illustrates the class structure within this package.

\begin{figure}[htbp]
    \centering
    \resizebox{\textwidth}{!}{
    \begin{tikzpicture}[
        node distance=2.5cm and 3.5cm, % Dọc = 2.5cm, Ngang = 3.5cm
        % --- STYLES ---
        uml_class/.style={
            draw, rectangle, 
            minimum width=4.5cm, minimum height=1.5cm, 
            align=center, 
            fill=gray!5, 
            font=\bfseries\large, 
            drop shadow={opacity=0.15},
            thick
        },
        % Style riêng cho Interface
        uml_interface/.style={
            draw, rectangle, % Viền đứt
            minimum width=4.5cm, minimum height=1.5cm, 
            align=center, 
            fill=white, % Nền trắng
            font=\bfseries\large, 
            drop shadow={opacity=0.15},
            thick
        },
        uml_package_style/.style={
            draw, rectangle, 
            inner sep=1cm, 
            fill=white, 
            drop shadow={opacity=0.2},
            rounded corners=2pt
        },
        uml_tab_style/.style={
            draw, rectangle, 
            fill=white, 
            minimum width=5cm, minimum height=1cm, 
            font=\bfseries\Large, 
            anchor=south west
        },
        % Quan hệ
        rel_impl/.style={-{Triangle[open, length=4mm, width=4mm]}, dashed, thick},
        rel_assoc/.style={-, thick}
    ]

        % 1. VẼ CÁC CLASS (Dùng positioning relative để tự động căn khoảng cách)
        
        % Class trung tâm
        \node[uml_class] (controller) {Controller Contract};
        
        % Interface nằm bên TRÁI Controller (cách 3.5cm)
        \node[uml_interface, left=of controller] (ireq) {<<Interface>> \\ IRequestHandler};
        
        % Verifier nằm bên PHẢI Controller (cách 3.5cm)
        \node[uml_class, right=of controller] (verifier) {SignatureVerifier};
        
        % Action nằm bên DƯỚI Controller (cách 2.5cm)
        \node[uml_class, below=of controller] (req_action) {RequestAction};

        % 2. VẼ CÁC ĐƯỜNG KẾT NỐI
        
        % (1) Controller implements Interface (Mũi tên chỉ về phía Interface)
        \draw[rel_impl] (controller) -- (ireq);
        
        % (2) Controller uses SignatureVerifier (Đường thẳng)
        \draw[rel_assoc] (controller) -- (verifier);
        
        % (3) Controller uses RequestAction (Đường thẳng)
        \draw[rel_assoc] (controller) -- (req_action);

        % 3. VẼ KHUNG PACKAGE (LAYER BACKGROUND)
        \begin{pgfonlayer}{background}
            % Fit bao gồm tất cả các node + padding
            \node[uml_package_style, fit=(ireq) (controller) (verifier) (req_action)] (pkg_box) {};
            
            % Vẽ Tab tên Package
            \node[uml_tab_style] at (pkg_box.north west) {pkg EVMController};
        \end{pgfonlayer}

    \end{tikzpicture}
    }
    \caption{Detailed Design of EVM Controller Package}
    \label{fig:evm_detailed_design}
\end{figure}

\textbf{Design Explanation:}
\begin{itemize}
    \item \textbf{Controller Contract:} This is the core contract deployed on the EVM chain. It manages user requests and orchestrates the cross-chain interaction flow.
    \begin{itemize}
        \item Interface Implementation: The contract implements the IRequestHandler interface, defining the standard methods for processing external requests.
        \item Usage Relationships: It has direct associations with RequestAction and SignatureVerifier classes. The Controller Contract utilizes RequestAction to structure and validate incoming request data and relies on SignatureVerifier to perform cryptographic checks on user signatures.
    \end{itemize}
    
    \item \textbf{RequestAction:} A data structure class that encapsulates all the necessary parameters for a cross-chain request (e.g., nonce, action type, amount, destination chain ID). It is used by the Controller Contract to hold and process incoming requests.
    
    \item \textbf{SignatureVerifier:} This utility class is responsible for validating the authenticity of a user's signature. It takes the message $M$ and the signature $\sigma$ as input and verifies if they were generated by the owner of the intended EVM address. This is a critical security component that prevents unauthorized actions.
\end{itemize}


\section{Detailed Design}

This section presents the comprehensive design specification for the Multi-chain Stablecoin Protocol. It decomposes the system into three core layers: Smart Contract Design (On-chain), Server Application Design (Off-chain), and Database Design (Persistence). The level of detail provided herein serves as the blueprint for the implementation phase.

\subsection{Smart Contract Design}
The smart contract layer is the backbone of the system, enforcing the financial logic and state immutability. Due to the hybrid architecture, the design is split into the EVM Controller (Solidity) and the Solana Hub (Rust/Anchor).

\subsubsection{EVM Controller Design}
The \texttt{ControllerContract} is deployed on EVM-compatible chains (e.g., Ethereum, BSC). It acts as a gateway for users to lock assets and receive cross-chain messages.

\textbf{1. Class Specification: ControllerContract}

Table \ref{tab:evm_attributes} details the state variables responsible for asset custody and concurrency control.

\begin{table}[H]
    \centering
    \renewcommand{\arraystretch}{1.3}
    \begin{tabularx}{\textwidth}{|l|l|X|}
    \hline
    \textbf{Attribute Name} & \textbf{Data Type} & \textbf{Description} \\ \hline
    \texttt{owner} & \texttt{address} & The address of the governance timelock or admin authorized to pause the contract. \\ \hline
    \texttt{guardian} & \texttt{address} & The verified address of the off-chain Guardian server allowed to submit callback transactions. \\ \hline
    \texttt{nonces} & \texttt{mapping(address => uint256)} & A counter for each user address to prevent replay attacks. It strictly enforces sequential request processing. \\ \hline
    \texttt{isLocked} & \texttt{mapping(address => bool)} & A Mutex lock flag. If \texttt{true}, the user cannot initiate a new request until the current cross-chain action is finalized. \\ \hline
    \texttt{vaults} & \texttt{mapping(address => mapping(address => uint256))} & Stores the collateral balance. Key 1: User Address, Key 2: Token Address. \\ \hline
    \end{tabularx}
    \caption{Attributes of ControllerContract (EVM)}
    \label{tab:evm_attributes}
\end{table}

Table \ref{tab:evm_methods} specifies the core methods utilized for user interactions and guardian callbacks.

\begin{table}[H]
    \centering
    \renewcommand{\arraystretch}{1.3}
    \begin{tabularx}{\textwidth}{|l|p{3.5cm}|X|}
    \hline
    \textbf{Method Name} & \textbf{Parameters} & \textbf{Logic Description} \\ \hline
    \texttt{requestAction} & \texttt{uint8 actionType, address token, uint256 amount, uint16 destChain} & \textbf{1.} Checks \texttt{isLocked[msg.sender]}. \newline \textbf{2.} Transfers tokens from User to Vault. \newline \textbf{3.} Increments \texttt{nonces}. \newline \textbf{4.} Emits \texttt{RequestCreated} event. \newline \textbf{5.} Sets \texttt{isLocked} to true. \\ \hline
    \texttt{updateState} & \texttt{address user, uint256 nonce, bool status, bytes data} & \textbf{1.} Verifies \texttt{msg.sender == guardian}. \newline \textbf{2.} Checks nonce matching. \newline \textbf{3.} If \texttt{status == true}: Mints stablecoin. \newline \textbf{4.} If \texttt{status == false}: Refunds collateral. \newline \textbf{5.} Sets \texttt{isLocked} to false. \\ \hline
    \texttt{verifySignature} & \texttt{bytes32 hash, bytes signature} & Internal helper to recover the signer address using \texttt{ecrecover} and compare it with the expected owner. \\ \hline
    \end{tabularx}
    \caption{Methods of ControllerContract (EVM)}
    \label{tab:evm_methods}
\end{table}

\textbf{2. Auxiliary Classes}

To maintain clean code, the logic for formatting requests is encapsulated in the \texttt{RequestAction} struct/library.

\begin{lstlisting}[language=C++, caption={Data Structure for RequestAction}, label={lst:request_struct}]
struct RequestPayload {
    uint256 nonce;
    uint256 amount;
    address tokenAddress;
    uint16 targetChainId;
    uint8 action; // 0: Deposit, 1: Withdraw, 2: Repay
    uint256 timestamp;
}
\end{lstlisting}

\subsubsection{Solana Hub Design}
The Solana environment hosts the complex business logic. The design leverages the Anchor framework's account model.

\textbf{1. Class Specification: MainContract (Processor)}

The MainContract acts as the instruction dispatcher. Unlike Solidity classes, this is implemented as a Rust module processing different \texttt{Contexts}.

\begin{table}[H]
    \centering
    \renewcommand{\arraystretch}{1.3}
    \begin{tabularx}{\textwidth}{|l|X|}
    \hline
    \textbf{Instruction Context} & \textbf{Description & Validation Logic} \\ \hline
    \texttt{InitializeWallet} & \textbf{Purpose:} Creates the PDA for a new user. \newline \textbf{Logic:} Derives address using \texttt{[b"wallet", user\_eth\_addr]}. Allocates storage space. \\ \hline
    \texttt{ProcessCrossChain} & \textbf{Purpose:} Handles incoming messages from the Guardian. \newline \textbf{Logic:} \newline 1. Invokes \texttt{Gateway} to verify Secp256k1 signature. \newline 2. Deserializes the payload. \newline 3. Calls \texttt{PositionManagement::update\_collateral}. \\ \hline
    \texttt{Liquidate} & \textbf{Purpose:} Allows keepers to liquidate under-collateralized positions. \newline \textbf{Logic:} Checks Oracle price feeds. If $HealthFactor < 1.0$, transfers collateral ownership. \\ \hline
    \end{tabularx}
    \caption{Instruction Logic of MainContract (Solana)}
    \label{tab:solana_methods}
\end{table}

\textbf{2. Class Specification: UniversalWallet (State)}

The \texttt{UniversalWallet} is the most critical data structure. It uses a composition pattern to store multi-chain data.

\begin{lstlisting}[language=C++, caption={Rust Struct for UniversalWallet}, label={lst:universal_wallet}]
#[account]
pub struct UniversalWallet {
    pub owner_evm_address: [u8; 20], // The identity key
    pub global_nonce: u64,           // Replay protection
    pub total_debt: u128,            // Aggregated debt
    pub chain_positions: Vec<ChainPosition>, // Vector of assets
    pub last_updated: i64,
    pub bump: u8,                    // PDA bump seed
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct ChainPosition {
    pub chain_id: u16,
    pub collateral_amount: u128,
    pub token_address: [u8; 20],
}
\end{lstlisting}

\textbf{3. Class Specification: GatewayContract}

The Gateway serves as the firewall. It does not store financial state but ensures authentication.

\begin{itemize}
    \item \textbf{Method:} \texttt{verify\_ethereum\_signature}
    \item \textbf{Input:} \texttt{message\_hash}, \texttt{signature\_recovery\_id}, \texttt{signature}
    \item \textbf{Algorithm:}
        \begin{enumerate}
            \item Construct the instruction for the native \texttt{keccak\_secp256k1} program.
            \item Perform a Cross-Program Invocation (CPI).
            \item Assert that the recovered address matches the \texttt{owner\_evm\_address} in the \texttt{UniversalWallet} account provided in the context.
        \end{enumerate}
\end{itemize}

\subsection{Server Application Design}
The Off-chain Infrastructure (Guardian) is a Node.js application designed as a persistent microservice. It bridges the EVM and Solana environments.

\subsubsection{Class Specification: GuardianService}
This is the main entry point of the application. It orchestrates the lifecycle of event listeners.

\begin{table}[H]
    \centering
    \renewcommand{\arraystretch}{1.3}
    \begin{tabularx}{\textwidth}{|l|l|X|}
    \hline
    \textbf{Property} & \textbf{Type} & \textbf{Description} \\ \hline
    \texttt{providers} & \texttt{Map<ChainID, JsonRpcProvider>} & Holds active connections to RPC nodes (Infura, Alchemy, QuickNode). \\ \hline
    \texttt{signer} & \texttt{Wallet} & The Ethers.js wallet instance loaded with the Guardian's private key. \\ \hline
    \texttt{queue} & \texttt{BetterQueue} & A persistent file-system queue to store events in case of server restart. \\ \hline
    \end{tabularx}
    \caption{GuardianService Properties}
\end{table}

\subsubsection{Class Specification: TxOrchestrator}
This class contains the core business logic for processing events and determining the necessary cross-chain actions.

\textbf{Key Method: processEvent(event)}
\begin{enumerate}
    \item \textbf{Input:} Raw log from EVM (topic, data).
    \item \textbf{Decode:} Uses the contract ABI to decode the log into a JSON object: `{nonce, user, amount, action}`.
    \item \textbf{Validation:} Checks the Redis cache to see if this `nonce` has already been processed (Idempotency check).
    \item \textbf{Transformation:} Converts the EVM amounts (wei) to Solana format (u64/u128).
    \item \textbf{Construction:} Builds a Solana Transaction containing the \texttt{Gateway::execute} instruction.
    \item \textbf{Submission:} Calls \texttt{SolanaRelayer.send()} and waits for confirmation.
\end{enumerate}

\subsubsection{Class Specification: SignatureVerifier (Off-chain)}
Before submitting to Solana (which costs gas), the Guardian performs a pre-check verification off-chain.

\begin{lstlisting}[language=JavaScript, caption={Off-chain Verification Logic}, label={lst:js_verify}]
class SignatureVerifier {
    static verify(message, signature, expectedAddress) {
        const msgHash = ethers.utils.hashMessage(message);
        const recoveredAddr = ethers.utils.recoverAddress(msgHash, signature);
        
        if (recoveredAddr.toLowerCase() !== expectedAddress.toLowerCase()) {
            throw new Error("Invalid Signature: Identity mismatch");
        }
        return true;
    }
}
\end{lstlisting}

\subsection{Database Design}
The system utilizes a Hybrid Database model. The "System of Record" is the blockchain, while the "System of Engagement" utilizes off-chain caching for performance.

\subsubsection{On-chain Data Schema (Solana Account Model)}
Solana stores data in "Accounts". The schema for the \texttt{UniversalWallet} PDA is designed for space efficiency.

\begin{itemize}
    \item \textbf{PDA Derivation Strategy:}
    \begin{equation}
        Pubkey = \text{findProgramAddress}([\text{"wallet"}, \text{user\_eth\_addr}], \text{ProgramID})
    \end{equation}
    \item \textbf{Storage Layout (Serialization):}
    \begin{itemize}
        \item \texttt{Discriminator (8 bytes)}: Unique identifier for the struct type.
        \item \texttt{Owner Address (20 bytes)}: Mapped EVM address.
        \item \texttt{Debt (16 bytes)}: u128 integer.
        \item \texttt{Positions Vector (Variable)}: 
        \begin{itemize}
            \item \texttt{ChainID (2 bytes)}
            \item \texttt{Token Address (20 bytes)}
            \item \texttt{Amount (16 bytes)}
        \end{itemize}
    \end{itemize}
    \item \textbf{Total Size Estimate:} $8 + 20 + 16 + 4 + (N \times 38)$ bytes. For 5 chains, approx 240 bytes.
\end{itemize}

\subsubsection{Off-chain Database Schema (Redis)}
Redis is used by the Guardian for two purposes: Event Deduplication and User Session State (for the Frontend).

\textbf{1. Key-Value Design for Idempotency}
\begin{itemize}
    \item \textbf{Key Format:} \texttt{processed\_tx:\{chain\_id\}:\{tx\_hash\}}
    \item \textbf{Value:} \texttt{Timestamp (ISO8601)}
    \item \textbf{TTL:} 24 hours (Events older than 24h are assumed settled).
\end{itemize}

\textbf{2. Key-Value Design for Nonce Management}
To ensure the Guardian sends transactions to Solana in correct order without nonce collisions.
\begin{itemize}
    \item \textbf{Key Format:} \texttt{guardian:solana:nonce}
    \item \textbf{Value:} \texttt{Integer (Current on-chain nonce)}
    \item \textbf{Logic:} Before sending, \texttt{INCR key}. If transaction fails, \texttt{DECR key}.
\end{itemize}

\subsubsection{Entity-Relationship Description}
Although NoSQL (Redis) and Blockchain are used, the logical relationships can be described as:

\begin{itemize}
    \item \textbf{One-to-One:} User (EVM Address) $\leftrightarrow$ UniversalWallet (Solana PDA). A single Ethereum address maps to exactly one Universal Wallet.
    \item \textbf{One-to-Many:} UniversalWallet $\rightarrow$ ChainPositions. One wallet can hold collateral from multiple chains (ETH from Mainnet, BNB from BSC).
    \item \textbf{Many-to-One:} RequestEvents $\rightarrow$ ControllerContract. The contract logs history of all requests.
\end{itemize}

This detailed design ensures that the data integrity is maintained across the distributed ledger while providing high-speed access for the application layer via the Redis cache.vvvvvvvvvvvvvvvv

\section{Application Building}
\subsection{Libraries and Tools}
Sinh viên liệt kê các công cụ, ngôn ngữ lập trình, API, thư viện, IDE, công cụ kiểm thử, v.v. mà mình sử dụng để phát triển ứng dụng. Mỗi công cụ phải được chỉ rõ phiên bản sử dụng. SV nên kẻ bảng mô tả tương tự như Bảng \ref{table:my_label}. Nếu có nhiều nội dung trình bày, sinh viên cần xoay ngang bảng.

\begin{table}[H]
\centering{}
    \begin{tabular}{lll}
        \hline
        \textbf{Mục đích} & \textbf{Công cụ}       & \textbf{Địa chỉ URL}    \\ \hline
        IDE lập trình     & Eclipse Oxygen a64 bit & http://www.eclipse.org/ \\ \hline
        v.v.              & v.v.                   & v.v.                    \\ \hline
        \end{tabular}
    \caption{Danh sách thư viện và công cụ sử dụng}
    \label{fig:my_label}
\end{table}

\subsection{Achievement}
Sinh viên trước tiên mô tả kết quả đạt được của mình là gì, ví dụ như các sản phẩm được đóng gói là gì, bao gồm những thành phần nào, ý nghĩa, vai trò?

Sinh viên cần thống kê các thông tin về ứng dụng của mình như: số dòng code, số lớp, số gói, dung lượng toàn bộ mã nguồn, dung lượng của từng sản phẩm đóng gói, v.v. Tương tự như phần liệt kê về công cụ sử dụng, sinh viên cũng nên dùng bảng để mô tả phần thông tin thống kê này.

\subsection{Illustration of main functions}
Sinh viên lựa chọn và đưa ra màn hình cho các chức năng chính, quan trọng, và thú vị nhất. Mỗi giao diện cần phải có lời giải thích ngắn gọn. Khi giải thích, sinh viên có thể kết hợp với các chú thích ở trong hình ảnh giao diện.

\section{Testing}
Phần này có độ dài từ hai đến ba trang. Sinh viên thiết kế các trường hợp kiểm thử cho hai đến ba chức năng quan trọng nhất. Sinh viên cần chỉ rõ các kỹ thuật kiểm thử đã sử dụng. Chi tiết các trường hợp kiểm thử khác, nếu muốn trình bày, sinh viên đưa vào phần phụ lục.
Sinh viên sau cùng tổng kết về số lượng các trường hợp kiểm thử và kết quả kiểm thử. Sinh viên cần phân tích lý do nếu kết quả kiểm thử không đạt.
\section{Deployment}
Sinh viên trình bày mô hình và/hoặc cách thức triển khai thử nghiệm/thực tế. Ứng dụng của sinh viên được triển khai trên server/thiết bị gì, cấu hình như thế nào. Kết quả triển khai thử nghiệm nếu có (số lượng người dùng, số lượng truy cập, thời gian phản hồi, phản hồi người dùng, khả năng chịu tải, các thống kê, v.v.)

\end{document}
